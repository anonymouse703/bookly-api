<?php

namespace App\Services\Booking;

use Carbon\Carbon;
use App\Models\Booking;
use App\Models\Service;
use App\Enums\Booking\Status;
use Illuminate\Support\Facades\DB;
use Illuminate\Database\Eloquent\ModelNotFoundException;
use Symfony\Component\HttpKernel\Exception\UnprocessableEntityHttpException;

class BookingService
{
    /**
     * Check if service exists and is active
     */
    public function isServiceBookable(int $serviceId): bool
    {
        return Service::where('id', $serviceId)
            ->where('is_active', true)
            ->exists();
    }

    /**
     * Check if time slot is available
     * 
     * Fixed: Proper overlap detection
     * A booking overlaps if:
     * - New start < Existing end AND New end > Existing start
     */
    public function isAvailable(
        int $serviceId,
        string $date,
        string $startTime,
        string $endTime,
        ?int $excludeBookingId = null
    ): bool {
        // Statuses that block availability
        $blockingStatuses = [
            Status::Pending->value,
            Status::Approved->value,
            Status::Rescheduled->value,
        ];

        $query = Booking::where('service_id', $serviceId)
            ->where('booking_date', $date)
            ->whereIn('status', $blockingStatuses)
            ->where(function ($q) use ($startTime, $endTime) {
                // Check for time overlap
                // Overlap occurs when: new_start < existing_end AND new_end > existing_start
                $q->where(function ($overlap) use ($startTime, $endTime) {
                    $overlap->where('start_time', '<', $endTime)
                           ->where('end_time', '>', $startTime);
                });
            });

        if ($excludeBookingId) {
            $query->where('id', '!=', $excludeBookingId);
        }

        return !$query->exists();
    }

    /**
     * Create a new booking
     */
    public function createBooking(array $data): Booking
    {
        return DB::transaction(function () use ($data) {
            return Booking::create([
                ...$data,
                'status' => Status::Pending->value,
                // reference_number will be auto-generated by the trait
            ]);
        });
    }

    /**
     * Generate unique reference number
     */
    private function generateReferenceNumber(): string
    {
        do {
            $reference = 'BK-' . strtoupper(uniqid());
        } while (Booking::where('reference_number', $reference)->exists());

        return $reference;
    }

    /**
     * Approve a pending booking
     */
    public function approveBooking(int $id): Booking
    {
        $booking = Booking::findOrFail($id);

        if ($booking->status !== Status::Pending->value) {
            throw new UnprocessableEntityHttpException('Only pending bookings can be approved.');
        }

        // Double-check availability before approving
        if (!$this->isAvailable(
            $booking->service_id,
            $booking->booking_date,
            $booking->start_time,
            $booking->end_time,
            $booking->id
        )) {
            throw new UnprocessableEntityHttpException('This time slot is no longer available.');
        }

        $booking->update([
            'status' => Status::Approved->value,
            'approved_at' => now(),
        ]);

        return $booking;
    }

    /**
     * Cancel a booking
     */
    public function cancelBooking(int $id, string $reason): Booking
    {
        $booking = Booking::findOrFail($id);

        if (!Status::from($booking->status)->canBeCancelled()) {
            throw new UnprocessableEntityHttpException('This booking cannot be cancelled.');
        }

        $booking->update([
            'status' => Status::Cancelled->value,
            'cancellation_reason' => $reason,
            'cancelled_at' => now(),
        ]);

        return $booking;
    }

    /**
     * Request a refund
     */
    public function requestRefund(int $id, ?string $reason): Booking
    {
        $booking = Booking::findOrFail($id);

        if (!Status::from($booking->status)->canRequestRefund()) {
            throw new UnprocessableEntityHttpException('Refund cannot be requested for this booking.');
        }

        $booking->update([
            'status' => Status::RefundRequested->value,
            'refund_reason' => $reason,
            'refund_requested_at' => now(),
        ]);

        return $booking;
    }

    /**
     * Approve a refund request
     */
    public function approveRefund(int $id, float $amount): Booking
    {
        $booking = Booking::findOrFail($id);

        if ($booking->status !== Status::RefundRequested->value) {
            throw new UnprocessableEntityHttpException('No pending refund request found.');
        }

        if ($amount > $booking->total_price) {
            throw new UnprocessableEntityHttpException('Refund amount cannot exceed booking total.');
        }

        $booking->update([
            'status' => Status::Refunded->value,
            'refund_amount' => $amount,
            'refund_approved_at' => now(),
        ]);

        return $booking;
    }

    /**
     * Deny a refund request
     */
    public function denyRefund(int $id, string $reason): Booking
    {
        $booking = Booking::findOrFail($id);

        if ($booking->status !== Status::RefundRequested->value) {
            throw new UnprocessableEntityHttpException('No pending refund request found.');
        }

        $booking->update([
            'status' => Status::RefundDenied->value,
            'refund_denied_at' => now(),
            'refund_denial_reason' => $reason,
        ]);

        return $booking;
    }

    /**
     * Mark booking as no-show
     */
    public function markAsNoShow(int $id): Booking
    {
        $booking = Booking::findOrFail($id);

        if (!in_array($booking->status, [Status::Pending->value, Status::Approved->value])) {
            throw new UnprocessableEntityHttpException('Only pending or approved bookings can be marked as no-show.');
        }

        $booking->update([
            'status' => Status::NoShow->value,
            'no_show_at' => now(),
        ]);

        return $booking;
    }

    /**
     * Reschedule a booking
     */
    public function rescheduleBooking(
        int $id,
        string $newDate,
        string $newStart,
        string $newEnd
    ): Booking {
        $booking = Booking::findOrFail($id);

        if (!Status::from($booking->status)->canBeRescheduled()) {
            throw new UnprocessableEntityHttpException('This booking cannot be rescheduled.');
        }

        // Check if new slot is available
        if (!$this->isAvailable(
            $booking->service_id,
            $newDate,
            $newStart,
            $newEnd,
            $booking->id
        )) {
            throw new UnprocessableEntityHttpException('The new time slot is not available.');
        }

        // Calculate new total hours and price
        $startTime = Carbon::parse($newStart);
        $endTime = Carbon::parse($newEnd);
        $totalHours = $startTime->diffInHours($endTime);
        $service = Service::findOrFail($booking->service_id);
        $totalPrice = $service->price * $totalHours;

        $booking->update([
            'original_booking_date' => $booking->booking_date,
            'original_start_time' => $booking->start_time,
            'original_end_time' => $booking->end_time,
            'booking_date' => $newDate,
            'start_time' => $newStart,
            'end_time' => $newEnd,
            'total_hours' => $totalHours,
            'total_price' => $totalPrice,
            'status' => Status::Rescheduled->value,
            'rescheduled_at' => now(),
        ]);

        return $booking;
    }
}